[
["importing-data-with-r.html", "2 Importing Data with R 2.1 Part 1 2.2 Importing data from flat files with utils", " 2 Importing Data with R 2.1 Part 1 Anotações para o curso do Datacamp ministrado pelo Filip Schouwenaars. Aqui aprenderemos a importar dados no R para começar análises. Estaremos trabalhando com variados tipos de arquivos. 2.2 Importing data from flat files with utils O que faremos quando precisamos transitar de Excel para R? Nesse curso aprenderemos a trabalhar com dados de 5 tipos de dados: 2.2.1 Flat files, arquivos achatados “Arquivos com estrutura de campos horizontal – cada registro corresponde a uma linha de dados onde os campos estão organizados posicionalmente ou por algum tipo de separador (vírgula, espaço em branco etc)” Fonte 2.2.1.1 read.csv - vírgulas O que fazemos quando os dados estão separados por vírgulas? CSV = Valores Separados por Vírgulas wanted_df &lt;- read.csv(&quot;states.csv&quot;, stringsAsFactors = False) Se o arquivo não estiver no diretório de trabalho, terá que escrever o seu PATH(caminho). Por exemplo, se estiver na pasta denominada dados no seu diretório de trabalho, escrevá &quot;dados/state.csv&quot;. Poderá alternativamente usar caminho &lt;- file.path(&quot;-&quot;, &quot;datasets&quot;, &quot;states.csv&quot;) para encontrar a path que utilizará e guardar numa variável como caminho. stringsAsFactors é FALSE, pois o default é TRUE, porém não queremos puxar os dados no formato de caracteres como categorias. 2.2.1.2 read.delim - indentação O que fazemos quando os dados estão separados por indentações? read.delim(&quot;states.txt&quot;, # path do arquivo colClasses = c(&quot;character&quot;, # OPCIONAL: colocar as classes das colunas &quot;character&quot;, #muito bom se quiser especificar apenas &quot;numeric&quot;, #algumas colunas com caracteres como &quot;numeric&quot;), #categoria. &quot;NULL&quot; elimina a coluna. stringsAsFactors = FALSE) 2.2.1.3 read.table - qualquer formato O que faremos quando os dados estão malucos? A quantidade de argumentos são absurdos, devido a amplitude dos casos específicos possíveis. Vamos olhar o caso específico do arquivo states2.txt. read.table(&quot;states2.txt&quot;, # o path do arquivo header = TRUE, # se a primeira linha são os nomes das variáveis sep = &quot;/&quot;, # o qu separa os dados stringsAsFactors = FALSE) # se as variáveis guardando caracteres são categorias. Aprendizado aleatório: max(), mostra o maior valor de um vetor which.max(), mostra o local do maior valor 2.2.1.4 Conclusão - Wrappers read.table() # é a forma genérica de read.csv() # o wrapper para CSV e read.delim() # o wrapper para arquivos .txt com indentação Os últimos utilizam o primeiro com diferentes argumentos preformatados. # São identicos read.table(&quot;states.csv&quot;, header = TRUE, sep = &quot;,&quot;, stringsAsFactors = FALSE) read.csv(&quot;states.csv&quot;, stringsAsFactors = FALSE) # e read.table(&quot;states.csv&quot;, header = TRUE, sep = &quot;\\t&quot;, stringsAsFactors = FALSE) read.delim(&quot;states.csv&quot;, stringsAsFactors = FALSE) read.csv2() # e read.delim2() # são configurações para diferenças regionais, lidando com # separadores para decimais, etc. 2.2.1.5 Tidyverse 2.2.1.5.1 readr - csv em geral Ambos abaixo puxam da mesma forma, porém a do Hadley automatiza algumas coisas como a questão das categorias. Porém a saída do read_csv é um tibble e não uma tabela. library(readr) read_csv(&quot;states.csv&quot;) read.csv(&quot;states.csv&quot;, stringsAsFactors = FALSE) A função abaixo puxa arquivos texto separados por indentação. library(readr) read_tsv(&quot;states.txt&quot;) read.csv(&quot;states.txt&quot;, stringsAsFactors = FALSE) A função principal é a read_delim() Ambos abaixo puxam os mesmos dados. library(readr) read_delim(&quot;states.txt&quot;) read.table(&quot;states.txt&quot;, header = TRUE, sep = &quot;/&quot;, stringsAsFactors = FALSE) O argumento col_names pode ser usado para atribuir nomes de colunas, se for FALSE serão atribuídos nomes como X1, X2 e X3. col_types especificam os tipos das colunas. Tem como simplificar esse input: &quot;cidl_&quot; == c(&quot;character&quot;, &quot;double&quot;, &quot;integer&quot;, &quot;logical&quot;, &quot;skip&quot;&quot;) Outra forma de associar colunas a determinadas estruturas e tipos seria usando collectors ou coletores. Abaio temos os coletores as variáveis fac e int. fac &lt;- col_factor(levels = c(&quot;Beef&quot;, &quot;Meat&quot;, &quot;Poultry&quot;)) int &lt;- col_integer() hotdogs_factor &lt;- read_tsv(&quot;hotdogs.txt&quot;, col_names = c(&quot;type&quot;, &quot;calories&quot;, &quot;sodium&quot;), col_types = list(fac, int, int)) Temos também o argumento skip que pula linhas, considerando a linha de nomes (portanto tendo que ser renomeadas), e n_max que limita a quantidade de linhas que serião puxadas. 2.2.1.5.2 package (pacote) data.table:fread Criados por Matt Dowle e Arn Srinivasan, esse pacote é muit rápido. Foi feito para manipulação de dados e tem uma função para importar dados fread(). É parecido com read.csv(). Todavia fread organiza os dados automaticamente, adicionando nomes quando não existem e aceitando os nomes quando existem, por exemplo. Ele faz as mesma coisas para separadores e os tipos das colunas. library(data.table) Os argumentos drop e select funcionam para escolher quais colunas manter ao puxar uma série de dados. Servem tanto para especificar colunas por nome quanto por número. fread(&quot;path/to/file.txt&quot;, drop = 2:4) fread(&quot;path/to/file.txt&quot;, select = c(1, 5)) fread(&quot;path/to/file.txt&quot;, drop = c(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) fread(&quot;path/to/file.txt&quot;, select = c(&quot;a&quot;, &quot;e&quot;)) 2.2.2 Dados do Excel 2.2.2.1 readxl Estaremos utilizando o readxl do Hadley Wickham, da tidyverse. library(readxl) Arquivos Excel são dados no formato tabular agrupados por sheets. Existem duas funções excel_sheets() e read_excel. O primeiro lista os sheets diferentes do arquivo excel, enquanto o segundo importa tal sheet como um tibble. &gt; dir() [1] &quot;cities.xlsx&quot; &gt; excel_sheets(&quot;cities.xlsx&quot;) [1] &quot;year_1990&quot; &quot;year_2000&quot; &gt; read_excel(&quot;cities.xlsx&quot;, sheet = número/nome do sheet) # exemplos idênticos &gt; read_excel(&quot;cities.xlsx&quot;, sheet = 1) &gt; read_excel(&quot;cities.xlsx&quot;, sheet = &quot;year_1990&quot;) # uma forma mais rápida para puxar tudo seri por um lapply &gt; dados &lt;- lapply(excel_sheets(&quot;cities.xlsx&quot;), read_excel, path = &quot;cities.xlsx&quot;) 2.2.2.1.1 Argumentos de read_excel Existe o argumento col_names que leva TRUE, FALSE, ou c(nomes). col_types leva tipos de colunas: text (texto), numeric (número), date (data) e blank (evitar a coluna). skip pula linhas. n_max é o máximo número de linhas a ler. 2.2.2.2 gdata library(gdata) Existem alternativas ao pacote anterior, vamos olhar esse do Gregory Warnes. É uma série de ferramentas para manipulação de dados em inúmeras áreas. Iremos utilizar o read.xls(). Não existe função para ler sheets separados. Usa a linguagem de programação Perl para funcionar. Ela converte os dados xls em csv, que depois é lido usando read.csv. Isso é bom pra quem conhece os argumentos de read.table, mas é muito ineficiente. Está sendo comentado aqui, pois no momento da gravação da aula, read_excel ainda estava sob forte modificação por ser novo e gdata já era mais estável. 2.2.2.2.1 Argumentos de read.xls Todos os argumentos de read.csv podem ser utilizados. 2.2.2.3 XLConnect Criado por Martin Studer, é a forma mais completa de trabalhar com arquivos de excel no R. Qualquer ação que você faria no Excel, consegue fazer dentro do R por meio da linguegem de programação Java. Editar sheets de excel, formatar dados… library(XLConnectJars) library(XLConnect) ## XLConnect 0.2-15 by Mirai Solutions GmbH [aut], ## Martin Studer [cre], ## The Apache Software Foundation [ctb, cph] (Apache POI), ## Graph Builder [ctb, cph] (Curvesapi Java library) ## http://www.mirai-solutions.com ## https://github.com/miraisolutions/xlconnect É importante instalar “Oracle’s Java Development Kit” (JDK) anteriormente: rJava. O primeiro passo depois de carregar a biblioteca, é colocar o workbook numa variável. book &lt;- loadWorkbook(&quot;cities.xlsx&quot;) Verificará olhando a estrutura que o objeto book é um workbook, que funciona como uma ponte entre R e Excel. Para obter os nomes dos sheets podemos utilizar getSheets(nome do arquivo). Para ler os dados do sheet usamos readWorksheet(). Podemos usar o argumento sheet para especificar qual sheet queremos. Tem mais, podemos usar startRow, endRow, startCol e endCol para especificar exatamente qual quadrado de dados queremos. Para fazer uma análise geral do arquivo como um todo, pode-se fazer o seguinte: my_book &lt;- loadWorkbook(&quot;urbanpop.xlsx&quot;) sheets &lt;- getSheets(my_book) all &lt;- lapply(sheets, readWorksheet, object = my_book) str(all) 2.2.3 Bases de Dados (PostgneSQL, MySQL) 2.2.4 Web 2.2.5 Software de Estatística (SPSS, STATA, SAS) "]
]
